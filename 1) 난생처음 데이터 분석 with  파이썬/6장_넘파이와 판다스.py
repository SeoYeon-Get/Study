# -*- coding: utf-8 -*-
"""난생처음_6장.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NB1Ipw4otBCW6mY-HV9cbQf4DnLuA6ux

# **6장. 넘파이와 판다스**
"""

# 차원 : 관측하고자 하는 데이터의 속성의 수 또는 측정 항목의 수
# 스칼라 : 0차원 배열. 배열에서 값을 표현하는 가장 기본 단위
# 벡터 : 1차원 배열. 스칼라(값)을 여러 개를 나열한 튜플을 떠올리면 됨.
# 행렬 : 2차원 배열. 1차원 배열 여러 개를 묶은 배열ㅇ
# 텐서 : 벡터의 집합. 3차원 이상의 배열을 말함.

# 배열의 Rank : 차원의 수
# Shape : 배열의 차원과 크기
# 예) 행이 3개이고 열이 4개인 2차원 배열은 rank = 2, shape = (3,4)

# ndarray : 넘파이의 다차원 배열, 기본 데이터 구조
# 특징
# - 자료형이 모두 같은 데이터를 담은 다차원 배열
# - 정수 또는 실수(부동 소수점 수)를 저장한다.
# - 배열 데이터에도 순서가 있으므로 인덱싱과 슬라이싱이 가능하다.

# 넘파이 배열의 인덱싱과 축
# 배열이 3차원일 때, 면->행->열 순으로 인덱스를 붙인다.
# 2차원 넘파이 배열에서, 0번 축 방향으로 행 인덱스가 증가.
# 3차원 넘파이 배열에서, 0번 축 방향으로 면 인덱스가 증가, 1번축은 행 인덱스, 2번 축은 열 인덱스가 증가함.

# 판다스
# - 데이터프레임 자료구조를 제공하여 데이터 분석을 돕는 파이썬 패키지
# 시리즈 : 인덱스와 값이 한 쌍을 이루는 1차원 자료구조 객체. 리스트는 값만 있고 인덱스가 0부터 자동
#         생성되지만, 시리즈는 사용자가 직접 인덱스를 정할 수 있음. 딕셔너리와 성격이 유사.
# 데이터프레임 : 판다스의 기본 구조인 자료구조 객체. 시리즈 여러 개를 묶어서 데이터프레임을 만들 수 있으므로
#               데이터프레임의 형태는 2차원 배열과 비슷함. 각 시리즈는 데이터프레임의 열이 됨.
#               데이터프레임은 행 인덱스, 열 이름(또는 열 인덱스), 값으로 구성됨

# 넘파이와 판다스 비교
# 넘파이 : 다차원 배열 객체, 정교한 브로드캐스팅, C/C++/포트란(Fortran)코드 통합 구현을 통한 속도 개선,
#         수학적 알고리즘 제공
# 판다스 : 대용량 데이터 처리, 시각적으로 알아보기 편리한 표 형태, 데이터 분석 도구 제공(결측치 처리, 관계 연산, 시계열)

import numpy as np

list1 = [1, 2, 3, 4] #열이 4개 있는 1차원 배열
a = np.array(list1)
print('a.shape: ', a.shape)
print('a[0]: ', a[0])

b = np.array([[1,2,3],[4,5,6]])
print('b.shape : ', b.shape)
print('b[0,0]: ', b[0,0])
print('b[0]: ', b[0])

a = np.zeros(2)
print('a\n', a)
b = np.zeros((2,2))
print('b\n', b)
c = np.ones((2,3))
print('c\n', c)
d = np.full((2,3), 5)
print('d\n', d)
e = np.eye(3)
print('e\n', e)

a = np.array([1,2], dtype = np.float64)
print(a.dtype)
#print(a)

a_i8 = a.astype(np.int8) # 정수형 요소 -> 요소 하나에 메모리를 8비트씩 사용함
print(a_i8.dtype)

arr = np.array([[0, 1, 2], [3, 4, 5]])

print('type(arr):',type(arr))
print('arr.ndim:',arr.ndim)
print('arr.dtype:',arr.dtype)
print('arr.itemsize:',arr.itemsize)
print('arr.size:',arr.size)
print('arr.nbytes:',arr.nbytes)
print('arr.T:\n',arr.T)
print('arr.shape:',arr.shape)

#flatten(): 다차원 배열을 1차원 배열로 변경. 이 함수는 항상 새로운 메모리를 할당한다는 특징이
#           있음. flatten()함수를 실행해도 배열 원본은 변경되지 않음.

#1차원 배열 생성하기
a = np.arange(8)
print('a\n', a)

#다차원 배열로 변경하기
a.shape = (2,4)
print('shape\n', a)

#1차원 배열로 변경하기
print('flatten\n', a.flatten())

#resize 함수로 모양 변경하기
a.resize((4,2))
print('resize\n', a)

a = np.array([[0, 1, 2], [3, 4, 5]])
print('a\n', a)

b = a.transpose()
print('b\n', b)
c = a.T
print('c\n', c)

#확인문제-1
a = np.arange(10)
a.shape = (2,5)
print(a)
print(a.T)

#확인문제-2
import numpy as np
list1 = [[1,2,3],
         [4,5,6],
         [7,8,9]]

a = np.array(list1)
print(a[1:3, :1])

# 넘파이 배열 다루기
# 마스킹(논리값 인덱싱(Boolean indexing)) : 엑셀의 필터처럼 조건에 맞는 값을 출력하는 기능
# 데이터 양이 많을 때 반복문으로 조건을 검사하지 않고도 원하는 데이터를 찾을 수 있음

mask = np.array([0, 1, 1, 0], dtype=bool) #마스크 배열 생성
print(mask)

data = np.random.randn(4,2) #평균이 0이고 표준편차가 1인 정규분포를 따르는 난수를 생성
print('\ndata 출력\n',data) #랜덤 데이터 배열 data는 책과 다르게 나타남

print('\n마스킹된 데이터 출력\n',data[mask])
print('\n마스킹 역전된 데이터 출력\n',data[~mask])

#코드 6-8
posit = data[data > 0]
print('양수 데이터 출력', '\n',posit)

#다중 조건
over1 = data[1][data[1] > 0]
print('두 번째 행의 양수 데이터 출력','\n',over1)

#유니버설 함수 : 덧셈, 뺄셈, 곱셈, 거듭제곱처럼 배열 요소끼리의 기본 연산을 수행하는 함수
#브로드캐스팅 : 둘 중 작은 차원인 배열을 변형하여 큰 차원의 배열이 맞춘 다음 두 배열을
#              요소별로 연산하는 동작.

#배열 복사
# - 얕은 복사 : 등호(=)를 이용하는 복제. 배열의 데이터 자체가 새로운 배열로 복사되지 않고
#              원본 데이터의 주소가 복사된다. 원본 배열을 수정하면 원본을 참조하는 복사본이
#              함께 바뀐다. 복사본을 수정해도 원본이 함께 바뀐다.
# - 깊은 복사 : copy() 함수를 사용함. 배열 복사본을 생성하므로 원본을 수정해도 복사본이 바뀌
#              지 않는다. 복사본의 데이터나 모양을 변경해도 원본에 영향을 주지 않음

#얕은 복사
a = np.arange(6)
b = a   # 변수 a의 값 = 배열 자체가 아니라, 넘파이 배열의 첫번째 요소가 들어있는 메모리 주소
print(a)
print(b is a)

b[0] = 10
print(a)

#깊은 복사
#넘파이 배열의 첫번째 요소가 들어있는 메모리 주소를 a의 값으로 저장하고, copy()함수로 a가
#가리키는 배열을 통째로 복사하여 만든다. c는 복사된 배열을 가리키게 함
a = np.arange(6)
c = a.copy()

c[0] = 20
print('A: ', a)
print('C: ', c)

a = np.array([3, 2, 5, 1, 4])

print('원본\n',a)
print('정렬 후\n',np.sort(a)) # 배열을 정렬해서 반환, 원본 유지

print('원본\n',a)
print('정렬한 인덱스\n',np.argsort(a)) #정렬된 배열의 원래 인덱스를 반환

a.sort() # 배열 정렬, 원본을 정렬함
print('원본\n',a)

#확인문제-3
a = np.array([1,2,3])
b = np.array([4])
c = np.add(a, b)
print(c)

#LAB - 우수 초콜릿 분석
import numpy as np
data = np.loadtxt('/content/sample_data/chocolate_rating.csv', delimiter = ',')
print('차원: ', data.ndim)
print('모양: ', data.shape)
print('원소 수: ', data.size)
print(data)
# 데이터 첫번째 열 : 초콜릿 번호
# 두 번째 열 : 평점을 기록한 년도
# 세 번째 열: 카카오 함유율
# 네 번째 열: 평점

ratings_mean = data[:,3].mean()
print(ratings_mean)

high_level = data[data[:,3]>= 4]
#print(high_level)
high_id = high_level[:, 0].astype(np.int64)
print('우수 초콜릿 수: ', high_id.size)
print(high_id)

#우수 초콜릿의 카카오 함유량 빈도 분석
high_kakao = high_level[:,2]
unique_values, value_counts = np.unique(high_kakao, return_counts=True)
print('카카오 함유량: ', unique_values)
print('함유량별 빈도수: ', value_counts)

max_index = np.argmax(value_counts) #np.argmax() : 최대값의 인덱스 반환
print(unique_values[max_index])
print('우수 초콜릿', high_id.size, '가지 중', value_counts[max_index],\
      '가지의 카카오 함유량이', unique_values[max_index] * 100, '%입니다.')

#판다스 시리즈 객체 - 모든 원소가 같은 자료형이어야 함.

import pandas as pd

a = pd.Series([1,2,3,4])
print(a)
b = pd.Series([1,2,3], index = ['a', 'b', 'c'])
print(b)

# DataFrame() : 데이터프레임 생성. 데이터프레임에 데이터를 할당할 때 파이썬의 리스트, 딕셔너리,
#               넘파이 배열을 활용할 수 있음.

list1 = list([['한빛', '남자', '20', '180'],
              ['한결', '남자', '21','177'],
              ['한라', '여자','20', '160']])
col_names = ['이름', '성별', '나이', '키']
pd.DataFrame(list1, columns = col_names)

dict1 = {'이름' : {0:'한빛', 1:'한결', 2:'한라'},
        '성별': {0:'남자', 1:'남자',2:'여자'},
        '나이':{0:'20', 1:'21',2:'20'},
        '키': {0:'180', 1:'177', 2:'160'}}
pd.DataFrame(dict1)

import numpy as np

arr1 = np.array([['한빛', '남자', '20', '180'],
              ['한결', '남자', '21','177'],
              ['한라', '여자','20', '160']])

col_names = ['이름', '성별', '나이', '키']

pd.DataFrame(arr1, columns=col_names)

list1 = list([['허준호','남자','30','183'],
              ['이가원','여자','24','162'],
              ['배규민','남자','23','179'],
              ['고고림','남자','21','182'],
              ['이새봄','여자','28','160'],
              ['이보람','여자','26','163'],
              ['이루리','여자','24','157'],
              ['오다현','여자','24','172']])
col_names = ['이름','성별','나이','키']
df = pd.DataFrame(list1, columns=col_names)
df

df.to_csv('./files2.csv', header = False, index = False, encoding='utf-8')
df2 = pd.read_csv('./files.csv', sep = ',')
df2

print(df.columns)

print(df.describe())

df.describe()
#top : 제일 개수가 많은 값, 제일 먼저 나온 값
#frequency : 개수

print(df.head(3))

df.tail(5)

df.sort_index(axis=0).head() # 행 기준 정렬

#나이 열과 키 열을 기준으로 행을 정렬하기
df.sort_values(by=['나이', '키'], ascending=False)

df[['이름', '키']]

#iloc(): 인덱스로 데이터를 조회할 수 있음.
df.iloc[1:4, 0:3]

df[df['키'] > 180] #키 열의 데이터 자료형이 문자열

list1 = list([['허준호','남자',30,183],
              ['이가원','여자',24,162],
              ['배규민','남자',23,179],
              ['고고림','남자',21,182],
              ['이새봄','여자',28,160],
              ['이보람','여자',26,163],
              ['이루리','여자',24,157],
              ['오다현','여자',24,172]])
col_names = ['이름','성별','나이','키']
df = pd.DataFrame(list1, columns=col_names)

df[df['키'] > 180]

df[df['나이'].isin([21,23])] #리스트 요소와 일치하는 데이터 조회

df[(df['성별'] == '여자') & (df['키']>160)] #두 조건식을 동시에 만족하는 데이터 조회

df[(df['나이'] >=28 ) | (df['성별'] == '남자')] # 두 조건식 중 하나 이상 만족하는 데이터 조회

df[df['이름'].str.contains('봄')] #특정 문자열을 포함하는 문자열 데이터 조회

df.describe() #위의 describe() 출력결과가 다름 -> 나이와 키 값이 숫자형

df.loc[4, '키'] = df.loc[4, '키'] + 5 # 인덱스로 조회한 데이터를 수정
df.loc[[4]]

#반복 연산자 : 명령 반복 실행
df.loc[1:3, '키'] = ['모름']*3
df

#확인문제
df.loc[1:3, '키'] = [162, 179, 182]
df

#set_index()
df.set_index('이름', inplace = True) #inplace = True를 지정하면 작업을 데이터프레임 원본에 적용
# False로 지정하거나 옵션을 지정하지 않을 시, 원본이 유지됨
df

#열 추가
df['보너스'] = df['나이'] * 10000
df

#열 삭제
df.drop('보너스', axis = 1, inplace = True)
df

del df['보너스']

# reset_index() : 기본 인덱스로 복구
df.reset_index(inplace = True)
df

#replace() : 데이터를 다른 값으로 치환
req_cond = {'성별' : {'남자' : 1, '여자' : 0}}
df2 = df.replace(req_cond)
df2.head()

req_cond2= {'성별' : {1 : '남자', 0 : '여자'}}
df2 = df.replace(req_cond2)
df2

mean_gender = df.groupby(by=['성별'], as_index = False)['키'].mean()
# as_index 옵션을 True로 하면 계산 결과가 시리즈로 출력되고, False로 하면 계산 결과가 데이터프레임으로 출력됨.
mean_gender.rename(columns={'키':'평균 키'}, inplace = True)

std_gender = df.groupby(by=['성별'], as_index = False)['키'].std()
std_gender.rename(columns={'키': '키의 표준편차'}, inplace = True)

new_df = pd.merge(mean_gender , std_gender)
new_df

#LAB - 강의 시간표 분석
import pandas as pd
list = list([['C1', '인공지능개론', 'R1', 3],
             ['C2', '웃음치료', 'R2', 2],
             ['C3', '경영학', 'R3', 3],
             ['C4', '3D디자인', 'R4', 4],
             ['C5', '스포츠경영', 'R2', 2],
             ['C6', '예술의 세계', 'R3', 1]])

col_names = ['과목번호', '과목명', '강의실', '시간수']
df = pd.DataFrame(list, columns = col_names)

df.to_csv('./timetable.csv', header = True, index = False, encoding='utf-8')

df2 = pd.read_csv('./timetable.csv', sep=',')
df2['교수'] = ['김예희', '오정현', '인세훈', '이새봄', '배유진', '이가원']
df2

max_hour = df2.groupby(by=['강의실'], as_index = False)['시간수'].max()

max_hour